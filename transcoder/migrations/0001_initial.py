# Generated by Django 6.0 on 2025-12-12 12:04

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Channel',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100, unique=True)),
                ('enabled', models.BooleanField(default=True)),
                ('input_type', models.CharField(choices=[('udp_multicast', 'UDP Multicast (MPEG-TS)'), ('rtsp', 'RTSP'), ('rtmp', 'RTMP'), ('file', 'File')], max_length=20)),
                ('input_url', models.CharField(help_text="For multicast: e.g. udp://@224.2.2.2:2001 (we'll add fifo_size & overrun options automatically).", max_length=512)),
                ('multicast_interface', models.CharField(blank=True, help_text='Optional: e.g. eth0. Leave blank to use system default.', max_length=64)),
                ('output_type', models.CharField(choices=[('hls', 'HLS (m3u8)'), ('rtmp', 'RTMP'), ('udp_ts', 'UDP TS Unicast'), ('file_ts', 'File (TS)'), ('file_mp4', 'File (MP4)')], max_length=20)),
                ('output_target', models.CharField(help_text='For HLS: directory path; for RTMP/UDP: URL (udp://ip:port, rtmp://...).', max_length=512)),
                ('record_enabled', models.BooleanField(default=True, help_text='If on, we are allowed to record this channel to disk.')),
                ('recording_path_template', models.CharField(default='recordings/{channel}/{date}/', help_text='Recording path. Relative paths are under MEDIA_ROOT. Use {channel}, {date}, {time} placeholders.', max_length=512)),
                ('recording_segment_minutes', models.PositiveIntegerField(default=60, help_text='Length of each recording segment in minutes.')),
                ('auto_delete_after_segments', models.PositiveIntegerField(blank=True, help_text='Maximum number of most recent segments to keep in each recording folder. Older segments beyond this count may be deleted. Leave blank to ignore.', null=True)),
                ('video_mode', models.CharField(choices=[('copy', 'Copy (no transcode)'), ('transcode', 'Transcode')], default='copy', max_length=16)),
                ('audio_mode', models.CharField(choices=[('copy', 'Copy (no transcode)'), ('transcode', 'Transcode'), ('disable', 'Disable audio')], default='copy', max_length=16)),
                ('video_codec', models.CharField(default='h264', help_text='Used only when transcoding (e.g. h264, hevc).', max_length=16)),
                ('audio_codec', models.CharField(default='aac', help_text='Used only when transcoding audio.', max_length=16)),
                ('hardware_preference', models.CharField(choices=[('auto', 'Auto (NVIDIA → Intel → CPU)'), ('nvidia', 'Force NVIDIA (if available)'), ('intel', 'Force Intel QSV (if available)'), ('cpu', 'Force CPU')], default='auto', help_text='AUTO = NVIDIA → Intel → CPU; or force one.', max_length=16)),
                ('target_width', models.PositiveIntegerField(blank=True, help_text='E.g. 1920. If null, keep source width.', null=True)),
                ('target_height', models.PositiveIntegerField(blank=True, help_text='E.g. 1080. If null, keep source height.', null=True)),
                ('video_bitrate', models.CharField(blank=True, help_text='E.g. 4000k. If blank, FFmpeg decides.', max_length=16)),
                ('monday', models.BooleanField(default=True)),
                ('tuesday', models.BooleanField(default=True)),
                ('wednesday', models.BooleanField(default=True)),
                ('thursday', models.BooleanField(default=True)),
                ('friday', models.BooleanField(default=True)),
                ('saturday', models.BooleanField(default=True)),
                ('sunday', models.BooleanField(default=True)),
                ('start_time', models.TimeField(blank=True, help_text='Local start time (HH:MM). If Start time and End time are both set to 00:00, the channel runs for the entire day.', null=True)),
                ('end_time', models.TimeField(blank=True, help_text='Local end time (HH:MM). If earlier than Start time, the channel runs overnight. If Start time and End time are both set to 00:00, the channel runs for the entire day.', null=True)),
                ('date_from', models.DateField(blank=True, help_text='Optional: only apply from this date (inclusive).', null=True)),
                ('date_to', models.DateField(blank=True, help_text='Optional: only apply up to this date (inclusive).', null=True)),
                ('auto_delete_enabled', models.BooleanField(default=False, help_text="If enabled, old recordings will be automatically deleted based on 'auto_delete_after_days'.")),
                ('auto_delete_after_days', models.PositiveIntegerField(default=7, help_text='Delete recordings older than this many days.')),
                ('timeshift_delay_minutes', models.PositiveIntegerField(blank=True, help_text="Delay in minutes for time-shift playback. Used when mode is 'Record + Time-shift' or 'Playback from recordings'.", null=True)),
                ('timeshift_output_udp_url', models.CharField(blank=True, help_text='UDP TS URL for delayed output, e.g. udp://239.0.0.10:2001?ttl=1&pkt_size=1316', max_length=512)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
            options={
                'ordering': ['name'],
            },
        ),
        migrations.CreateModel(
            name='RecurringSchedule',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100)),
                ('purpose', models.CharField(choices=[('live_forward', 'Live forward'), ('record', 'Record'), ('playback', 'Playback (delayed)')], default='record', max_length=16)),
                ('enabled', models.BooleanField(default=True)),
                ('monday', models.BooleanField(default=True)),
                ('tuesday', models.BooleanField(default=True)),
                ('wednesday', models.BooleanField(default=True)),
                ('thursday', models.BooleanField(default=True)),
                ('friday', models.BooleanField(default=True)),
                ('saturday', models.BooleanField(default=True)),
                ('sunday', models.BooleanField(default=True)),
                ('start_time', models.TimeField(help_text='Local start time (HH:MM). If Start time and End time are both set to 00:00, the schedule runs for the entire day.')),
                ('end_time', models.TimeField(help_text='Local end time (HH:MM). If later than Start time, the schedule runs within the same day. If earlier than Start time, the schedule runs overnight. If Start time and End time are both set to 00:00, the schedule runs for the entire day.')),
                ('date_from', models.DateField(blank=True, help_text='Optional: only apply from this date (inclusive).', null=True)),
                ('date_to', models.DateField(blank=True, help_text='Optional: only apply up to this date (inclusive).', null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('channel', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='recurring_schedules', to='transcoder.channel')),
            ],
            options={
                'ordering': ['name'],
            },
        ),
        migrations.CreateModel(
            name='Schedule',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100)),
                ('purpose', models.CharField(choices=[('live_forward', 'Live forward'), ('record', 'Record'), ('playback', 'Playback (delayed)')], default='live_forward', max_length=16)),
                ('enabled', models.BooleanField(default=True)),
                ('start_at', models.DateTimeField(help_text='When this job should start (server/local time).')),
                ('end_at', models.DateTimeField(help_text='When this job should stop (server/local time).')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('channel', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='schedules', to='transcoder.channel')),
            ],
            options={
                'ordering': ['-start_at'],
            },
        ),
        migrations.CreateModel(
            name='TimeShiftProfile',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('enabled', models.BooleanField(default=False)),
                ('delay_minutes', models.PositiveIntegerField(default=180, help_text='Delay between live input and delayed output, in minutes (e.g. 180 = 3 hours).')),
                ('output_udp_url', models.CharField(help_text='UDP TS URL for delayed output, e.g. udp://239.0.0.10:2001?ttl=1&pkt_size=1316', max_length=512)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('channel', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='timeshift_profile', to='transcoder.channel')),
            ],
            options={
                'verbose_name': 'Time-shift profile',
                'verbose_name_plural': 'Time-shift profiles',
            },
        ),
    ]
