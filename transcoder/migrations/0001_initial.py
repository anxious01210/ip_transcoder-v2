# Generated by Django 6.0 on 2025-12-12 13:12

import django.core.validators
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Channel',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100, unique=True)),
                ('enabled', models.BooleanField(default=True)),
                ('input_type', models.CharField(choices=[('udp_multicast', 'UDP Multicast (MPEG-TS)'), ('rtsp', 'RTSP'), ('rtmp', 'RTMP'), ('file', 'File')], max_length=20)),
                ('input_url', models.CharField(help_text="For multicast: e.g. udp://@224.2.2.2:2001 (we'll add fifo_size & overrun options automatically).", max_length=512)),
                ('multicast_interface', models.CharField(blank=True, help_text='Optional: e.g. eth0. Leave blank to use system default.', max_length=64)),
                ('output_type', models.CharField(choices=[('udp_ts', 'UDP TS Unicast'), ('hls', 'HLS (m3u8)'), ('rtmp', 'RTMP'), ('file_ts', 'File (TS)'), ('file_mp4', 'File (MP4)')], default='udp_ts', max_length=20)),
                ('output_url', models.CharField(help_text='For UDP/RTMP: URL (udp://ip:port, rtmp://...). For HLS: directory path.', max_length=512)),
                ('delay_seconds', models.PositiveIntegerField(default=0, help_text='0 = no delay. Max 86400 seconds (24 hours).', validators=[django.core.validators.MaxValueValidator(86400)])),
                ('record_enabled', models.BooleanField(default=True, help_text='If on, the channel records TS segments to disk (required for time-shift).')),
                ('recording_path_template', models.CharField(default='recordings/{channel}/{date}/', help_text='Recording path. Relative paths are under MEDIA_ROOT. Use {channel}, {date}, {time} placeholders.', max_length=512)),
                ('recording_segment_minutes', models.PositiveIntegerField(default=60, help_text='Length of each recording segment in minutes.')),
                ('auto_delete_enabled', models.BooleanField(default=False, help_text='If enabled, old recording segments will be deleted automatically based on the thresholds below.')),
                ('auto_delete_after_segments', models.PositiveIntegerField(blank=True, help_text='Maximum number of most recent segments to keep in each recording folder. Older segments beyond this count may be deleted. Leave blank to ignore.', null=True)),
                ('auto_delete_after_days', models.PositiveIntegerField(blank=True, help_text='Also delete segments older than this many days. Leave blank to ignore age-based cleanup.', null=True)),
                ('video_mode', models.CharField(choices=[('copy', 'Copy (no transcode)'), ('transcode', 'Transcode')], default='copy', max_length=16)),
                ('audio_mode', models.CharField(choices=[('copy', 'Copy (no transcode)'), ('transcode', 'Transcode'), ('disable', 'Disable audio')], default='copy', max_length=16)),
                ('video_codec', models.CharField(default='h264', help_text='Used only when transcoding (e.g. h264, hevc).', max_length=16)),
                ('audio_codec', models.CharField(default='aac', help_text='Used only when transcoding audio.', max_length=16)),
                ('hardware_preference', models.CharField(choices=[('auto', 'Auto (NVIDIA → Intel → CPU)'), ('nvidia', 'Force NVIDIA (if available)'), ('intel', 'Force Intel QSV (if available)'), ('cpu', 'Force CPU')], default='cpu', help_text='v3 baseline is CPU-only. Keep this field for future flexibility.', max_length=16)),
                ('target_width', models.PositiveIntegerField(blank=True, help_text='E.g. 1920. If null, keep source.', null=True)),
                ('target_height', models.PositiveIntegerField(blank=True, help_text='E.g. 1080. If null, keep source.', null=True)),
                ('video_bitrate', models.CharField(blank=True, help_text='E.g. 4000k. If blank, FFmpeg decides.', max_length=16)),
                ('monday', models.BooleanField(default=True)),
                ('tuesday', models.BooleanField(default=True)),
                ('wednesday', models.BooleanField(default=True)),
                ('thursday', models.BooleanField(default=True)),
                ('friday', models.BooleanField(default=True)),
                ('saturday', models.BooleanField(default=True)),
                ('sunday', models.BooleanField(default=True)),
                ('start_time', models.TimeField(blank=True, help_text='Local start time (HH:MM). If start_time == end_time, the channel runs the full day on selected weekdays.', null=True)),
                ('end_time', models.TimeField(blank=True, help_text='Local end time (HH:MM). If earlier than start_time, the channel runs overnight.', null=True)),
                ('date_from', models.DateField(blank=True, help_text='Optional: only apply from this date (inclusive).', null=True)),
                ('date_to', models.DateField(blank=True, help_text='Optional: only apply up to this date (inclusive).', null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
            options={
                'ordering': ['name'],
            },
        ),
    ]
